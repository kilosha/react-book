import React from 'react';
import { Typography, List, ListItemText } from '@mui/material';
import { CodeBlock } from 'react-code-blocks';

const VirtualDOM = () => {
    return (
        <div>
            <Typography variant="h4" paragraph>
                VirtualDOM
            </Typography>
            <Typography paragraph variant="h5">
                Что такое DOM?
            </Typography>
            <Typography paragraph>
                <b>DOM</b> - это сокращение от <b>"Document Object Model"</b> (объектная модель
                документа). Когда ты открываешь веб-страницу в браузере, браузер создает структуру
                документа, которую можно представить в виде дерева элементов. Эти элементы - это
                HTML-теги, например, div, p, h1 и другие. DOM позволяет нам манипулировать этой
                структурой, изменять содержимое, стили, добавлять и удалять элементы. Теперь
                представь, что у тебя есть большое React-приложение с множеством компонентов и
                элементов. Каждый раз, когда происходит изменение данных в приложении, React должен
                обновить DOM, чтобы отобразить эти изменения на странице. Но вместо того, чтобы
                непосредственно вносить изменения в реальный DOM, React использует виртуальный DOM.
            </Typography>
            <Typography paragraph>
                <b>Виртуальный DOM</b> - это промежуточное представление DOM в памяти компьютера.
                React создает виртуальное дерево элементов, которое точно соответствует текущему
                состоянию компонентов. Затем React сравнивает это виртуальное дерево с реальным DOM
                и определяет, какие изменения необходимо внести.
            </Typography>
            <Typography paragraph>
                Теперь, почему это так важно? Вот несколько причин:
                <List sx={{ margin: '0 20px' }}>
                    <ListItemText>
                        1. <b>Эффективность:</b> Виртуальный DOM позволяет React оптимизировать
                        обновление DOM. Вместо того, чтобы изменять каждый элемент по отдельности,
                        React находит минимальный набор изменений, которые необходимо внести, и
                        применяет их к реальному DOM. Это снижает нагрузку на браузер и улучшает
                        производительность приложения.
                    </ListItemText>
                    <ListItemText>
                        2. <b>Удобство программирования:</b> Работа с виртуальным DOM упрощает
                        разработку. Ты можешь думать о компонентах и их состояниях, не беспокоясь о
                        том, как React будет обновлять реальный DOM. React самостоятельно заботится
                        об эффективных изменениях.
                    </ListItemText>
                    <ListItemText>
                        3. <b>Переносимость:</b> Виртуальный DOM абстрагирует тебя от различий в
                        реализации DOM в разных браузерах. Ты можешь писать свое приложение, не
                        думая о том, какой браузер будет его запускать. React самостоятельно
                        обрабатывает эти различия.
                    </ListItemText>
                </List>
                В итоге, использование виртуального DOM позволяет React быть эффективной, удобной в
                использовании и переносимой библиотекой.
            </Typography>
            <Typography paragraph variant="h5">
                Reconciliation
            </Typography>
            <Typography paragraph>
                <b>Reconciliation</b> - это процесс, при котором React сравнивает предыдущее
                состояние компонента с новым состоянием и определяет, какие изменения нужно внести в
                пользовательский интерфейс.
            </Typography>
            <Typography paragraph>
                Представь, у нас есть компонент в React, который отображает некоторую информацию на
                экране. Когда происходят изменения в данных, например, пользователь вводит новое
                значение или получает обновленные данные с сервера, React должен обновить
                пользовательский интерфейс, чтобы отразить эти изменения.
            </Typography>
            <Typography paragraph>
                Reconciliation происходит по следующему сценарию:
                <List sx={{ margin: '0 20px' }}>
                    <ListItemText>
                        1. <b>Обновление состояния:</b> Когда состояние компонента изменяется, React
                        запускает процесс reconciliation. Он сравнивает предыдущее состояние
                        компонента с новым состоянием, чтобы определить, какие части интерфейса
                        нужно обновить.
                    </ListItemText>
                    <ListItemText>
                        2. <b>Сравнение элементов:</b> React сравнивает элементы, которые
                        представляют компоненты, и их дочерние элементы. Он анализирует их типы,
                        свойства и ключи, чтобы понять, какие элементы нужно обновить, добавить или
                        удалить.
                    </ListItemText>
                    <ListItemText>
                        3. <b>Обновление виртуального DOM:</b> React использует виртуальный DOM
                        (Virtual DOM), который является внутренним представлением интерфейса. Он
                        создает новое виртуальное дерево элементов на основе изменений состояния
                        компонента.
                    </ListItemText>
                    <ListItemText>
                        4. <b>Эффективные обновления:</b> React делает эффективные обновления,
                        минимизируя количество фактических изменений в реальном DOM. Он определяет,
                        какие элементы действительно нужно обновить, и применяет только эти
                        изменения в реальном DOM, чтобы избежать ненужных операций.
                    </ListItemText>
                </List>
            </Typography>
            <Typography paragraph variant="h5">
                Пример
            </Typography>
            <Typography paragraph>
                Рассмотрим пример счетчика, чтобы более подробно разобраться, как происходит процесс
                reconciliation в React.
            </Typography>
            <Typography paragraph>
                Предположим, у нас есть компонент Counter, который отображает значение счетчика и
                имеет кнопки для увеличения и уменьшения значения:
            </Typography>
            <CodeBlock
                language={'js'}
                text={`import React, { useState } from 'react';

function Counter() {
    const [count, setCount] = useState(0);

    const increment = () => {
    setCount(count + 1);
    };

    const decrement = () => {
    setCount(count - 1);
    };

    return (
    <div>
        <p>Count: {count}</p>
        <button onClick={increment}>Increment</button>
        <button onClick={decrement}>Decrement</button>
    </div>
    );
}

export default Counter;`}
            />
            <Typography paragraph>
                Теперь давай рассмотрим, как происходит reconciliation при взаимодействии с
                компонентом:
                <List sx={{ margin: '0 20px' }}>
                    <ListItemText>
                        1. При первом рендере компонента Counter, его начальное состояние count
                        равно 0.
                    </ListItemText>
                    <ListItemText>
                        2. React создает виртуальное дерево элементов (Virtual DOM) на основе
                        JSX-разметки. Он создает элементы для div, p, button, и т. д., а также
                        включает значение count в соответствующем месте интерфейса.
                    </ListItemText>
                    <ListItemText>
                        3. React обновляет реальный DOM, отображая созданный виртуальный DOM на
                        экране. Мы видим интерфейс счетчика с начальным значением 0 и кнопками для
                        увеличения и уменьшения значения.
                    </ListItemText>
                    <ListItemText>
                        4. Когда мы нажимаем кнопку "Increment" или "Decrement", вызываются
                        соответствующие функции increment или decrement. В этих функциях мы изменяем
                        значение count, используя функцию setCount.
                    </ListItemText>
                    <ListItemText>
                        5. После изменения состояния count, React запускает процесс reconciliation.
                        Он сравнивает предыдущий виртуальный DOM с новым виртуальным DOM, чтобы
                        определить, какие изменения необходимо внести в реальный DOM.
                    </ListItemText>
                    <ListItemText>
                        6. React определяет, что значение count изменилось, и обновляет
                        соответствующую часть интерфейса. Новое значение count отображается в p
                        элементе.
                    </ListItemText>
                    <ListItemText>
                        7. Вместо полного перерисовывания всего интерфейса, React применяет только
                        необходимые изменения в реальном DOM. В данном случае, он обновляет только
                        текстовое значение внутри p элемента.
                    </ListItemText>
                </List>
            </Typography>
            <Typography paragraph>
                Таким образом, при взаимодействии с компонентом Counter, React обновляет только те
                части интерфейса, которые реально нуждаются в изменениях. Это делает процесс
                обновления более эффективным и позволяет приложению работать более быстро.
            </Typography>
        </div>
    );
};

export default VirtualDOM;
